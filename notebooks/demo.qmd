# Example demo

```{julia}
using DmspElfinConjunction
import DmspElfinConjunction as DE
using DMSP, ELFINData
# using SPEDAS
using SpaceDataModel: setmeta
using GLMakie, SpacePhysicsMakie
using Dates, TimeseriesUtilities
using DataFrames, DataFramesMeta, DimensionalData
using IRBEM, GeoCotrans, GeoAACGM
using Beforerr
using Beforerr: add_labels!

using SpacePhysicsMakie: set_if_valid!

Beforerr.DEFAULT_FORMATS = [:png, :pdf]
includet("../src/plot.jl")
includet("../src/workload.jl")
includet("../src/demo.jl")
using .YLabel
set_Z_theme!()
```

```{julia}
probe = "a"
Δt = Minute(10)
mlats = nothing
# Good
id, trange = 16, [DateTime("2022-07-02T05:00"), DateTime("2022-07-02T05:10")]
id, trange = 17, [DateTime("2021-12-01T22:19:00"), DateTime("2021-12-01T22:28")]
id, trange = 17, [DateTime("2021-11-08T22:28"), DateTime("2021-11-08T22:32")]
# Poor
id, trange = 17, [DateTime("2020-04-25T13:10"), DateTime("2020-04-25T13:31")]
id, trange = 17, [DateTime("2020-07-03T15:00"), DateTime("2020-07-03T15:30")] # only three points for kappa fitting (overfitting)
id, trange = 18, [DateTime("2020-07-14T02:04"), DateTime("2020-07-14T02:34")] # only three points for kappa fitting (overfitting)
id, trange = 18, [DateTime("2020-07-06T20"), DateTime("2020-07-06T21:33")] # one large kappa (~20), but reasonable results
id, trange = 16, [DateTime("2020-07-04T22"), DateTime("2020-07-04T22:30")]

# Example demonstrating the uncertainty of our fitting with overlapping time, mlt, and mlat at the same time
# id, trange, mlats = 17, [DateTime("2021-04-12T01:33"), DateTime("2021-04-12T01:42")], -68:0.5:-67

# Pretty good example with overlapping time and mlt
id, trange, mlats, Δt = 17, [DateTime("2021-12-01T22:19:00"), DateTime("2021-12-01T22:28")], [-69., -65.], Minute(5)

# id, trange = 17, [DateTime("2021-11-08T22:28"), DateTime("2021-11-08T22:32")]

t0, t1 = trange
# Load ELFIN EPD data
begin
    elx_flux = ELFINData.epd_spectral(trange; probe) |> permutedims

    elx_gei_trange = extend(trange, Second(1))
    # julia> @b ELFIN.epd(trange, probe)
    # 1.320 ms (1334 allocs: 2.731 MiB)
    elx_gei = tview(
        DimArray(probe == "a" ? ELA_POS_GEI(elx_gei_trange) : ELB_POS_GEI(elx_gei_trange)),
        elx_gei_trange)
    elx_aacgm = gei2aacgm(elx_gei)
    elx_mlat = _mlat(elx_aacgm)
    elx_geo = gei2geo(elx_gei)
    elx_mlt = get_mlt(elx_geo)
    ae_max, ae = maxAE(elx_gei_trange)
    elx_flux_ratio = ELFINData.flux_ratio(elx_flux)
end

dmsp_flux = DMSP.flux(extend(trange, Δt), id)
dmsp_mlt, dmsp_mlat = get_mlt_mlat(id, extend(trange, Δt))
zoom_tr = timerange(tview(elx_flux.para, trange))
```

```{julia}
for x in (elx_flux.para, elx_flux.anti, elx_flux.prec, dmsp_flux)
    set_if_valid!(x.metadata, :yscale => log10, :ylabel => "Energy (keV)", :colorscale => log10, :colorrange => (1e3, 1e11))
end

elx_mlat = setmeta(elx_mlat, :label => "ELFIN")
dmsp_mlat = setmeta(dmsp_mlat, :labels => "DMSP")
zoom_tr = timerange(tview(elx_flux.para, trange))
tvars = (
    elx_flux.para, elx_flux.anti, elx_flux.prec,
    dmsp_flux,
    [elx_mlat, dmsp_mlat],
)
# tplot(tvars, zoom_tr...)
# Fail to plot in `Makie` 0.24: https://github.com/rafaqz/DimensionalData.jl/issues/1146
f = Figure(; size=(800, 500),)
axs = quicklook(f, trange, elx_flux, elx_mlt, elx_mlat, dmsp_flux, dmsp_mlt, dmsp_mlat; colormap=:batlow)
ylims!(axs[3], -84, -54)
f
easy_save("quicklook")
config = (; probe, id, trange, t0, t1)
easy_save(savename("quicklook", config))
```

![quicklook](../figures/quicklook.png)

## Flux Data by MLAT

```{julia}
using DmspElfinConjunction: PowerLawExpCutoff2, TransformKappaDistribution

elx_df = @chain get_trange_by_mlat(tview(elx_mlat, zoom_tr)) begin
    @rtransform! begin
        :mlt = local_mlt_mean(tview(elx_mlt, :trange))
        :flux = tmean(tview(elx_flux.prec, :trange)) |> sanitize_elfin_flux
    end
end
dmsp_df = get_flux_by_mlat(dmsp_flux, dmsp_mlat)
@rtransform! dmsp_df :flux = sanitize_dmsp_flux(:flux)

join_df = leftjoin(elx_df, dmsp_df, on=:mlat, makeunique=true, renamecols="_elx" => "_dmsp")

@chain join_df begin
    dropmissing!()
    @rtransform! @astable begin # Add MLT values for each MLAT bin
        :mlt_dmsp = local_mlt_mean(tview(dmsp_mlt, :trange_dmsp))
        :Δmlt = mlt_dist(:mlt_dmsp, :mlt_elx)
    end
    @rtransform! $AsTable = fit_two_flux(:flux_dmsp, :flux_elx)
    classify_precipitation!(elx_flux, elx_mlt; trange=:trange_elx)
end
sdf = @rsubset(join_df, :success, :Δmlt < 1, length(:flux_elx) >= 3 && all(view(:flux_elx, 1:3) .> FLUX_THRESHOLD))
# successful_fits = filter(r -> r.success, join_df)
```

We treat 0 as 0 for averaging, 0 for NaN for fitting.

## Demo Plotting

```{julia}
using StatsBase: counts
# mlats = nothing
demo_plot(Figure(; size=(900, 700)), zoom_tr, join_df, elx_flux, elx_mlt, elx_mlat, dmsp_flux, dmsp_mlt, dmsp_mlat; mlats, add_ratios=false, colormap=:cividis)
add_labels!(; position=Right(), padding=(0, 0, 0, 0))
easy_save("flux_with_fit")
# easy_save(savename("flux_with_fit", config))
```

![flux_with_fit](../figures/flux_with_fit.png)

![Good example with close MLT](../figures/flux_with_fit_id=17_probe=a_t0=2021-12-01T22:19:00_t1=2021-12-01T22:28:00.png)

![Bad example with close MLT](../figures/flux_with_fit_id=16_probe=a_t0=2020-07-04T22:00:00_t1=2020-07-04T22:30:00.png)

## Mechanisms

We may separate two mechanisms in ELFIN, and these mechanisms may work for DMSP energy range as well. Let us introduce R=|j_para-j_anti|/j_perp for ELFIN
[1] FLCS: R(maxE)>0.5 and R monotonically going down or stay above 0.5 with energy decrease to 63keV. maxE here is the maximum energy where ELFIN measure reliable precipitating fluxes. Additional criteria is night-side MLT sector and dipole L-shell>5
[2] whistler-mode waves: R(63keV)>0.25 and R monotonically going down or stay above 0.25 with energy increase
[1] and [2] criteria can be applied for individual ELFIN spins, and then 1o MLAT bin can be classified as: FLCS-only (>50% bins satisfy [1] and no bins satisfy [2]), whistler-only (>10% bins satisfy [2] and no bins satisfy [1]), mixed (>25% bins satisfy [1] and >10% bins satisfy [2]), no energetic precipitations (others)


```{julia}
includet("../../src/mechanisms.jl")
for i in 1:3
    mlt = sdf.elfin_mlt[i]
    trange = sdf.trange_elx[i]
    @info "MLT $mlt"
    mlats = tview(elx_mlat, trange).data
    @info "MLAT $mlats"
    flux = tview(elx_flux.prec, trange)
    flux_ratio = tview(elx_flux_ratio, trange)

    (n_total, n_flcs, n_whistler) = classify_precipitation(flux_ratio.data, flux.data, mlt)
    mechanism = classify(n_total, n_flcs, n_whistler)
    @info "Total $n_total spins mechanism $mechanism, with FLCS $n_flcs ($n_flcs/$n_total) Whistler $n_whistler ($n_whistler/$n_total)"
end
# println("FLCS")
```

## Comprehensive Parameter Analysis

Plotting model-calculated flux vs MLAT and how the PowerLawExpCutoff parameters change over MLAT.

1. Spatial Variations: How particle precipitation characteristics change with magnetic latitude
2. Spectral Hardness Trends: Whether spectra become harder/softer at different MLATs
3. Cutoff Energy Patterns: How the high-energy cutoff varies spatially
<!-- 4. Parameter Correlations: Relationships between spectral parameters that reveal physical processes -->

```@example demo
Es = energies(flux)
modeled_fluxes = @with successful_fits begin
    flux_modeled = stack(:model) do model
        model.(Es)
    end
    DimArray(flux_modeled', (X(:mlat), Y(Es)))
end
```