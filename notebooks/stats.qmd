# Statistics analysis

```{julia}
import Pkg
Pkg.activate("docs")
using DmspElfinConjunction, DMSP, ELFIN
using Dates
using TimeseriesUtilities
using DimensionalData, DataFrames, DataFramesMeta
using GeoCotrans, IRBEM
using SPEDAS
using Accessors

includet("../src/plot.jl")
includet("../src/workload.jl")
```


```{julia}
probe = "b"
tr = Date("2021-01-01"), Date("2022-08-01")
ids = 16:18

df = produce(tsplit(tr, Month), probe, ids)
```


```{julia}
using DmspElfinConjunction: A

γ_len = @optic _.γ
κ_len = @optic _.κ
const m1 = @optic _.model1
const m2 = @optic _.model2
```

TODO: investigate 1. why some E_c are so large 2. why some κ are so large and some are negative


```{julia}
f = Figure()
sdf = @chain df begin
    @rtransform(:E_c = E_c(m1_len(:model)))
    sort(:E_c; rev=true)
end
ax = plot_spectra(f[1, 1], sdf[1:3, :])
# ylims!(ax, 1.0e1, 1.0e12)
# axislegend(ax; position=:lb)
f
```

## Dependence analysis

```{julia}
using Statistics


sdf = @rsubset(df, 0 < κ_len(m2(:model)) < 20, E_c(m1(:model)) < 100, E_c(m2(:model)) < 100)
# Generate the plot
plot_all_means_by_ae_bin(sdf; binedges=5:15:200)
```


```{julia}
using CategoricalArrays
using Measurements

# Fix for AlgebraOfGraphics
# Base.typemin(x::Type{Measurement{Float64}}) = -Inf
# Base.typemax(x::Type{Measurement{Float64}}) = Inf

mean_std(x) = mean(x) ± std(x)

function plot_bin_stats!(ax, x, y)
    scatter!(ax, x, y)
    errorbars!(ax, x, y, whiskerwidth=8)
end

let binedges = 5:15:200
    tdf = @chain df begin
        @transform(
            :maxAE_bin = cut(:maxAE, binedges; extend=missing),
            :log_A1 = (log10 ∘ A ∘ m1).(:model),
            :E_c1 = (E_c ∘ m1).(:model),
            :γ = (γ_len ∘ m1).(:model),
            :log_A2 = (log10 ∘ A ∘ m2).(:model),
            :E_c2 = (E_c ∘ m2).(:model),
            :κ = (κ_len ∘ m2).(:model),
        )
        @rsubset!(20 > :κ > 0, :E_c1 < 100, :E_c2 < 100)
        @groupby(:maxAE_bin)
        combine(
            [:log_A1, :E_c1, :γ, :log_A2, :E_c2, :κ] .=> mean_std,
            :maxAE => mean; renamecols=false)
    end

    # https://github.com/MakieOrg/AlgebraOfGraphics.jl/issues/688
    # AoG does not support Errorbars
    # plt = data(tdf) * mapping(:maxAE, [:log_A1, :E_c1, :γ, :log_A2, :E_c2, :κ]) *
    #   (visual(Scatter) + visual(Errorbars, whiskerwidth=8)) * mapping(layout=AoG.dims(1))
    # draw(plt)

    f = Figure()
    x = tdf.maxAE
    ax = Axis(f[1, 1], ylabel="Mean log A1")
    plot_bin_stats!(ax, x, tdf.log_A1)
    # ylims!(ax, 0, 5)

    ax2 = Axis(f[2, 1], ylabel="Mean E_c (keV)")
    plot_bin_stats!(ax2, x, tdf.E_c1)
    ylims!(ax2, 0, 10)

    ax3 = Axis(f[3, 1], xlabel="AE (nT)", ylabel="Mean γ")
    plot_bin_stats!(ax3, x, tdf.γ)
    ylims!(ax3, -10, 5)

    ax4 = Axis(f[1, 2], ylabel="Mean log A2")
    plot_bin_stats!(ax4, x, tdf.log_A2)
    # ylims!(ax4, -10, 5)

    ax5 = Axis(f[2, 2], ylabel="Mean E_c2 (keV)")
    plot_bin_stats!(ax5, x, tdf.E_c2)
    ylims!(ax5, 0, 10)

    ax6 = Axis(f[3, 2], xlabel="AE (nT)", ylabel="Mean κ")
    plot_bin_stats!(ax6, x, tdf.κ)
    ylims!(ax6, 2, 6)
    f
end
```

### MLT, maxAE space

```{julia}
vars = [:log_A1, :E_c1, :γ, :log_A2, :E_c2, :κ]

tdf = let binedges_ae = [0, 100, 300], binedges_mlt = 0:2:24
    @chain df begin
        @transform(
            :maxAE_bin = cut(:maxAE, binedges_ae; extend=true),
            :mlt_bin = cut(:elfin_mlt, binedges_mlt; extend=missing),
            :log_A1 = (log10 ∘ A ∘ m1).(:model),
            :E_c1 = (E_c ∘ m1).(:model),
            :γ = (γ_len ∘ m1).(:model),
            :log_A2 = (log10 ∘ A ∘ m2).(:model),
            :E_c2 = (E_c ∘ m2).(:model),
            :κ = (κ_len ∘ m2).(:model),
        )
        @rsubset!(20 > :κ > 0, :E_c1 < 100, :E_c2 < 100)
        @groupby(:mlt_bin, :maxAE_bin)
        combine(vars .=> mean, renamecols=false)
        dropmissing!
    end
end
levels!(tdf.mlt_bin, ["[12, 14)", "[14, 16)", "[16, 18)", "[18, 20)", "[20, 22)", "[22, 24]", "[0, 2)", "[2, 4)", "[4, 6)", "[6, 8)", "[8, 10)", "[10, 12)"])

#  plot in such a way, that it will be MLT from 12 to 24, and then from 0 to 12, so 24=0 will be in the middle of figure
f = Figure(; size=(600, 900))

base_plt = data(tdf) * mapping(:mlt_bin, :maxAE_bin) * visual(Heatmap)
fpos = (f[1, 1], f[2, 1], f[3, 1], f[1, 2], f[2, 2], f[3, 2])
fgrids = map(fpos, vars) do fp, var
    sf = draw!(fp, base_plt * mapping(var))
    colorbar!(fp[0, 1], sf; vertical=:false)
    return sf
end
f11, f21, f31, f12, f22, f32 = fgrids
for sf in (f11, f21, f12, f22)
    hidexdecorations!(sf[1].axis)
end
for sf in (f12, f22, f32)
    hideydecorations!(sf[1].axis)
end

f
```

### Probability distributions

Probability distributions of observations in (Mlat, Ec) and (Mlat, gamma) spaces?

```{julia}
includet("../src/statplot.jl")
using PairPlots, AlgebraOfGraphics
using StatsBase
const AoG = AlgebraOfGraphics

E_c1(model) = E_c(m1_len(model))
E_c2(model) = E_c(m2_len(model))

# plot_parameter_distributions_aog(df; normalization=:pdf)
# plot_parameter_distributions_aog(df; normalization=:column)

# plot_parameter_distributions_aog(df, :mlat; normalization=:column)
plot_parameter_distributions_aog(dropmissing(df), :maxAE; normalization=:pdf, x_binedges=(0:20:400))
# plot_parameter_distributions_aog(dropmissing(df), :maxAE; normalization=:column, x_binedges=(0:20:1000))

```

```{julia}
# Use PairPlots for comprehensive parameter analysis
function plot_parameter_pairplots(df)
    # Create analysis DataFrame with all relevant parameters
    plot_df = DataFrame(
        mlat=df.mlat,
        E_c=E_c.(m1_len.(df.model)),
        γ=γ_len.(m1_len.(df.model)),
        κ=κ_len.(m2_len.(df.model)),
        success=df.success,
        Δmlt=df.Δmlt
    )

    # Filter for successful fits
    successful_df = @subset(plot_df, :success)

    if nrow(successful_df) == 0
        println("No successful fits found for plotting")
        return nothing
    end

    # Create comprehensive pair plot with all parameters
    return pairplot(successful_df[:, [:mlat, :E_c, :γ, :κ, :Δmlt]])
end

# Plot comprehensive pairwise analysis
plot_parameter_pairplots(df)
```

```{julia}
# Advanced AlgebraOfGraphics visualization with faceting and grouping
function plot_advanced_parameter_analysis(df)
    # Create comprehensive analysis DataFrame
    plot_df = DataFrame(
        mlat=df.mlat,
        E_c=E_c.(m1_len.(df.model)),
        γ=γ_len.(m1_len.(df.model)),
        κ=κ_len.(m2_len.(df.model)),
        success=df.success,
        Δmlt=df.Δmlt,
        id=df.id,
        # Create MLAT bins for grouping
        mlat_bin=cut(df.mlat, 5, labels=["High", "Mid-High", "Mid", "Mid-Low", "Low"])
    )

    # Filter for successful fits
    successful_df = @subset(plot_df, :success)

    if nrow(successful_df) == 0
        println("No successful fits found for plotting")
        return nothing
    end

    # Create multi-faceted analysis
    base = data(successful_df)

    # Density plots with grouping by DMSP satellite ID
    density_analysis = base *
                       mapping(:mlat => "MLAT (degrees)", :E_c => "E_c (keV)",
                           color=:id => nonnumeric, layout=:id => nonnumeric) *
                       (density() * visual(alpha=0.7) +
                        smooth() * visual(linewidth=2))

    # Scatter plot with trend analysis
    scatter_analysis = base *
                       mapping(:γ => "γ", :E_c => "E_c (keV)",
                           color=:mlat_bin => "MLAT Region",
                           markersize=:Δmlt => "ΔMLT") *
                       (visual(Scatter, alpha=0.7) +
                        smooth() * visual(linewidth=1.5))

    # Create figure with multiple panels
    f = Figure(size=(1600, 1000))

    # Panel 1: Density analysis by satellite
    draw!(f[1, :], density_analysis;
        axis=(title="E_c vs MLAT by DMSP Satellite",
            subtitle="Density distributions with trend lines"))

    # Panel 2: Parameter correlation analysis  
    draw!(f[2, 1], scatter_analysis;
        axis=(title="Parameter Correlations",
            subtitle="E_c vs γ colored by MLAT region, sized by ΔMLT"))

    # Panel 3: Distribution summary
    hist_plot = base *
                mapping(:E_c => "E_c (keV)", layout=:mlat_bin => nonnumeric) *
                histogram(bins=15) * visual(alpha=0.8, color=:steelblue)

    draw!(f[2, 2], hist_plot;
        axis=(title="E_c Distribution by MLAT Region",))

    return f
end

# Create advanced multi-panel analysis
plot_advanced_parameter_analysis(df)
```

```{julia}
# Statistical summary of the distributions
function summarize_parameter_distributions(df)
    successful_df = @subset(df, :success)

    println("=== Parameter Distribution Summary ===")
    println("Total successful fits: $(nrow(successful_df))")
    println("Total observations: $(nrow(df))")
    println("Success rate: $(round(nrow(successful_df)/nrow(df)*100, digits=2))%")
    println()

    # MLAT statistics
    println("MLAT Statistics:")
    println("  Range: $(round(minimum(successful_df.mlat), digits=2))° to $(round(maximum(successful_df.mlat), digits=2))°")
    println("  Mean: $(round(mean(successful_df.mlat), digits=2))°")
    println("  Std: $(round(std(successful_df.mlat), digits=2))°")
    println()

    # E_c statistics
    E_c_values = [row.model2.E_c for row in eachrow(successful_df) if haskey(row.model2, :E_c)]
    if !isempty(E_c_values)
        println("E_c Statistics:")
        println("  Range: $(round(minimum(E_c_values), digits=2)) to $(round(maximum(E_c_values), digits=2)) keV")
        println("  Mean: $(round(mean(E_c_values), digits=2)) keV")
        println("  Std: $(round(std(E_c_values), digits=2)) keV")
        println("  Median: $(round(median(E_c_values), digits=2)) keV")
        println()
    end

    # γ statistics
    gamma_values = [row.model1.γ for row in eachrow(successful_df) if haskey(row.model1, :γ)]
    if !isempty(gamma_values)
        println("γ Statistics:")
        println("  Range: $(round(minimum(gamma_values), digits=2)) to $(round(maximum(gamma_values), digits=2))")
        println("  Mean: $(round(mean(gamma_values), digits=2))")
        println("  Std: $(round(std(gamma_values), digits=2))")
        println("  Median: $(round(median(gamma_values), digits=2))")
    end
end

# Print statistical summary
summarize_parameter_distributions(df)
```








## Parameter Statistics and Correlations

```julia
#TODO: update this part
# Calculate parameter statistics and correlations
using Statistics

# Create summary statistics
param_stats = (
    plec_A_mean=mean([p.plec_A for p in param_analysis]),
    plec_A_std=std([p.plec_A for p in param_analysis]),
    plec_γ_mean=mean([p.plec_γ for p in param_analysis]),
    plec_γ_std=std([p.plec_γ for p in param_analysis]),
    plec_E_c_mean=mean([p.plec_E_c for p in param_analysis]),
    plec_E_c_std=std([p.plec_E_c for p in param_analysis]),
    sbpl_A_mean=mean([p.sbpl_A for p in param_analysis]),
    sbpl_A_std=std([p.sbpl_A for p in param_analysis]),
    sbpl_γ1_mean=mean([p.sbpl_γ1 for p in param_analysis]),
    sbpl_γ1_std=std([p.sbpl_γ1 for p in param_analysis]),
    sbpl_γ2_mean=mean([p.sbpl_γ2 for p in param_analysis]),
    sbpl_γ2_std=std([p.sbpl_γ2 for p in param_analysis]),
    sbpl_Eb_mean=mean([p.sbpl_Eb for p in param_analysis]),
    sbpl_Eb_std=std([p.sbpl_Eb for p in param_analysis])
)

@info "Parameter Statistics:" param_stats

# Create correlation plot between key parameters
f_corr = Figure(size=(1200, 900))

# PowerLawExpCutoff γ vs E_c
ax_corr1 = Axis(f_corr[1, 1], xlabel="Power Index γ (PowerLawExpCutoff)",
    ylabel="Cutoff Energy E_c (keV)", yscale=log10,
    title="PowerLawExpCutoff: γ vs E_c")
scatter!(ax_corr1, [p.plec_γ for p in param_analysis],
    [p.plec_E_c for p in param_analysis],
    color=mlats_all, colormap=:viridis, markersize=8)

# PowerLawExpCutoff A vs γ  
ax_corr2 = Axis(f_corr[1, 2], xlabel="Amplitude A (PowerLawExpCutoff)",
    ylabel="Power Index γ", xscale=log10,
    title="PowerLawExpCutoff: A vs γ")
scatter!(ax_corr2, [p.plec_A for p in param_analysis],
    [p.plec_γ for p in param_analysis],
    color=mlats_all, colormap=:viridis, markersize=8)

# SmoothBrokenPowerlaw γ1 vs γ2
ax_corr3 = Axis(f_corr[2, 1], xlabel="Power Index γ₁ (SBPL)",
    ylabel="Power Index γ₂ (SBPL)",
    title="SmoothBrokenPowerlaw: γ₁ vs γ₂")
scatter!(ax_corr3, [p.sbpl_γ1 for p in param_analysis],
    [p.sbpl_γ2 for p in param_analysis],
    color=mlats_all, colormap=:viridis, markersize=8)

# Break energy vs MLAT colored by PowerLawExpCutoff cutoff
ax_corr4 = Axis(f_corr[2, 2], xlabel="MLAT", ylabel="Break Energy Eb (keV)",
    yscale=log10, title="Break Energy vs MLAT")
scatter!(ax_corr4, mlats_all, [p.sbpl_Eb for p in param_analysis],
    color=[p.plec_E_c for p in param_analysis], colormap=:plasma, markersize=8)

# Add colorbars
Colorbar(f_corr[1:2, 3], colormap=:viridis, colorrange=extrema(mlats_all),
    label="MLAT")

f_corr
```
