## Loading ELFIN Flux and State Data

```{julia}
import Pkg
Pkg.activate("docs")
using DmspElfinConjunction, DMSP, ELFIN
using Dates
using TimeseriesUtilities
using DimensionalData, DataFrames, DataFramesMeta
using GeoCotrans, IRBEM
using SPEDAS
using Accessors

includet("../src/plot.jl")
includet("../src/workload.jl")
includet("../src/conjugation.jl")
```

```{julia}
probe = "b"
tr = ["2021-01-08", "2021-01-18"]
tr = Date("2021-08-01"), Date("2021-09-01")
# tr = ["2021-01-08", "2021-01-09"]
ids = 16:18
# elx_gei = ELFIN.gei(tr, probe)
ELFIN.epd(tr, probe)
# elx_flux = ELFIN.precipitating_flux(tr, probe)
```

### Finding Continuous Time Ranges

```{julia}
continuous_ranges = find_continuous_timeranges(elx_flux, Second(60))

# Print the continuous time ranges
println("Found $(length(continuous_ranges)) continuous time ranges:")
for (i, (start_time, end_time)) in enumerate(continuous_ranges)
    duration = end_time - start_time
    println("Range $i: $start_time to $end_time ($(round(duration, Minute)))")
end
```

## Trajectory conjunction finder

### MLAT and MLT differences

Filter time ranges (t0, t1) so that Δmlt < 1 and Δmlat < 8 for at least one DMSP within the time range (t0 - Δt, t1 + Δt)

```{julia}
Δt = Minute(10)
Δmlt_max = 1
Δmlat_max = 8
```

Filter with simultaneous Δmlt < 1 and Δmlat < 8 conditions:

```{julia}
valid_ranges_with_ids_simultaneous = find_simultaneous_conditions(
    continuous_ranges, elx_gei
)
```

Find time ranges where corresponding MLT differences are also within threshold after matching binned MLAT.

```{julia}
valid_ranges_with_ids = find_matched_mlat_conditions(
    continuous_ranges, elx_gei; ids, Δt, Δmlt_max
)
```

### Randomly check

For each valid range, get the fluxes and MLATs and fit the fluxes by MLAT

```{julia}
result = rand(valid_ranges_with_ids)

# result = valid_ranges_with_ids[13]
# result = valid_ranges_with_ids[14]
df, elfin, dmsp = workload(result...; elx_gei, elx_flux.prec)
```

```{julia}
using StatsBase

if nrow(df) > 0
    # random select three mlats
    mlats = sort!(sample(df.mlat, min(3, nrow(df)), replace=false))
    plot_flux_analysis(df, elfin, dmsp; mlats)[1]
else
    println("No valid data found")
end

```

```{julia}
plot_elfin_dmsp(result...; elx_flux=elx_flux.prec, elx_gei)
# plot_elfin_dmsp(valid_ranges_with_ids[4]...; elx_flux = elx_flux.prec, elx_gei)
```


### Plot distance metrics


```{julia}
dist(mlt0::Number, mlt1::Number) = min(mod(mlt0 - mlt1, 24), mod(mlt1 - mlt0, 24))
dist((mlt0, mlat0), (mlt1, mlat1); dmlt=1, dmlat=8) =
    ifelse(dist(mlt0, mlt1) < dmlt, 0, 1) *
    ifelse(abs(mlat0 - mlat1) < dmlat, 0, 1)

dist_exp((mlt0, mlat0), (mlt1, mlat1); dmlt=1, dmlat=8) =
    (1 - exp(-dist(mlt0, mlt1) / dmlt) *
         exp(-abs(mlat0 - mlat1) / dmlat))

distances = map(1:3) do id_idx
    map(1:length(elx_mlt)) do i
        dist_exp((elx_mlt[i], elx_aacgm.mlat[i]), (dmsp_xs_mlt[id_idx][i], dmsp_xs_aacgm[id_idx].mlat[i]))
    end
end
```

```{julia}
f = Figure()
# First axis for normalized MLAT and MLT
ax1 = Axis(f[1, 1], xlabel="Time", ylabel="Normalized Value", title="ELFIN MLAT and MLT")
ts = times(elfin_x_geo)
scatterlines!(ax1, (90 .- elx_aacgm.mlat) ./ 180, label="MLAT (normalized) = (90 - MLAT) / 180")
scatterlines!(ax1, elx_mlt ./ 24, label="MLT (normalized) = MLT / 24")
axislegend(ax1, position=:rt)

# Second axis for MLT differences
ax2 = Axis(f[2, 1], xlabel="Time", ylabel="MLT Difference (normalized)", title="MLT Difference ELFIN vs DMSP")
foreach(1:3) do id_idx
    lines!(ax2, dist.(elx_mlt, dmsp_xs_mlt[id_idx]) ./ 24)
end

# Third axis for MLAT differences
ax3 = Axis(f[3, 1], xlabel="Time", ylabel="MLAT Difference (normalized)", title="MLAT Difference ELFIN vs DMSP")
foreach(1:3) do id_idx
    lines!(ax3, abs.(elx_aacgm.mlat .- dmsp_xs_aacgm[id_idx].mlat) ./ 180)
end

# Fourth axis for distances
ax4 = Axis(f[4, 1], xlabel="Time", ylabel="Distance", title="Combined Distance Metric")
foreach(1:3) do i
    lines!(ax4, ts, distances[i], label="DMSP F$(i+15)")
end
axislegend(ax4, position=:rt)

# Link x-axes so they zoom/pan together
linkxaxes!(ax1, ax2, ax3, ax4)

f
```


