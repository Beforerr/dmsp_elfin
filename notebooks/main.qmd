## Parameter Statistics and Correlations

```julia
#TODO: update this part
# Calculate parameter statistics and correlations
using Statistics

# Create summary statistics
param_stats = (
    plec_A_mean=mean([p.plec_A for p in param_analysis]),
    plec_A_std=std([p.plec_A for p in param_analysis]),
    plec_γ_mean=mean([p.plec_γ for p in param_analysis]),
    plec_γ_std=std([p.plec_γ for p in param_analysis]),
    plec_E_c_mean=mean([p.plec_E_c for p in param_analysis]),
    plec_E_c_std=std([p.plec_E_c for p in param_analysis]),
    sbpl_A_mean=mean([p.sbpl_A for p in param_analysis]),
    sbpl_A_std=std([p.sbpl_A for p in param_analysis]),
    sbpl_γ1_mean=mean([p.sbpl_γ1 for p in param_analysis]),
    sbpl_γ1_std=std([p.sbpl_γ1 for p in param_analysis]),
    sbpl_γ2_mean=mean([p.sbpl_γ2 for p in param_analysis]),
    sbpl_γ2_std=std([p.sbpl_γ2 for p in param_analysis]),
    sbpl_Eb_mean=mean([p.sbpl_Eb for p in param_analysis]),
    sbpl_Eb_std=std([p.sbpl_Eb for p in param_analysis])
)

@info "Parameter Statistics:" param_stats

# Create correlation plot between key parameters
f_corr = Figure(size=(1200, 900))

# PowerLawExp γ vs E_c
ax_corr1 = Axis(f_corr[1, 1], xlabel="Power Index γ (PowerLawExp)",
    ylabel="Cutoff Energy E_c (keV)", yscale=log10,
    title="PowerLawExp: γ vs E_c")
scatter!(ax_corr1, [p.plec_γ for p in param_analysis],
    [p.plec_E_c for p in param_analysis],
    color=mlats_all, colormap=:viridis, markersize=8)

# PowerLawExp A vs γ  
ax_corr2 = Axis(f_corr[1, 2], xlabel="Amplitude A (PowerLawExp)",
    ylabel="Power Index γ", xscale=log10,
    title="PowerLawExp: A vs γ")
scatter!(ax_corr2, [p.plec_A for p in param_analysis],
    [p.plec_γ for p in param_analysis],
    color=mlats_all, colormap=:viridis, markersize=8)

# SmoothBrokenPowerlaw γ1 vs γ2
ax_corr3 = Axis(f_corr[2, 1], xlabel="Power Index γ₁ (SBPL)",
    ylabel="Power Index γ₂ (SBPL)",
    title="SmoothBrokenPowerlaw: γ₁ vs γ₂")
scatter!(ax_corr3, [p.sbpl_γ1 for p in param_analysis],
    [p.sbpl_γ2 for p in param_analysis],
    color=mlats_all, colormap=:viridis, markersize=8)

# Break energy vs MLAT colored by PowerLawExp cutoff
ax_corr4 = Axis(f_corr[2, 2], xlabel="MLAT", ylabel="Break Energy Eb (keV)",
    yscale=log10, title="Break Energy vs MLAT")
scatter!(ax_corr4, mlats_all, [p.sbpl_Eb for p in param_analysis],
    color=[p.plec_E_c for p in param_analysis], colormap=:plasma, markersize=8)

# Add colorbars
Colorbar(f_corr[1:2, 3], colormap=:viridis, colorrange=extrema(mlats_all),
    label="MLAT")

f_corr
```


## Loading ELFIN Flux Data


```{julia}
# TODO: update this part
probe = "b"
tr = ["2021-01-01", "2021-02-01"]

epd_ds = elfin.epd(tr; probe, level="l2")
elx_flux = DimArray(getproperty(epd_ds, Symbol(:el, probe, :_pef_hs_nflux_para)))
elx_flux_perp = DimArray(getproperty(epd_ds, Symbol(:el, probe, :_pef_hs_nflux_perp)))
elx_energies = pyconvert(Vector{Float64}, PySPEDAS.get_data("el$(probe)_pef_energies_mean"; xarray=false))

elx_flux = rebuild(elx_flux, dims=(Ti(parent(elx_flux.dims[1])), Y(elx_energies .* 1e3)))
elx_flux_perp = rebuild(elx_flux_perp, dims=(Ti(parent(elx_flux_perp.dims[1])), Y(elx_energies .* 1e3)))

promote_cdf_attributes!.((elx_flux.metadata, elx_flux_perp.metadata))
set_if_valid!(elx_flux.metadata, :yscale => log10, :scale => log10, :colorrange => (1e1, 1e6))
set_if_valid!(elx_flux_perp.metadata, :yscale => log10, :scale => log10, :colorrange => (1e1, 1e6))
replace!.((elx_flux, elx_flux_perp), 0 => NaN)
```

Loading ELFIN State Data

```{julia}
elx_state = elfin.state(tr; probe)
elx_gei = DimArray(getproperty(elx_state, Symbol(:el, probe, :_pos_gei)))
elx_gei = set(elx_gei, Dim{:time} => Ti)
```

### Finding Continuous Time Ranges

```{julia}
using SPEDAS
using SPEDAS: find_continuous_timeranges

continuous_ranges = find_continuous_timeranges(elx_flux, Second(60))

# Print the continuous time ranges
println("Found $(length(continuous_ranges)) continuous time ranges:")
for (i, (start_time, end_time)) in enumerate(continuous_ranges)
    duration = end_time - start_time
    println("Range $i: $start_time to $end_time ($(round(duration, Minute)))")
end
```

## Trajectory conjunction finder

```{julia}
id = 16
probe = "b"
tr = ["2021-01-01", "2021-02-01"]


elfin_x_geo = Speasy.get_data("ssc/elfin$probe/geo", tr...)

ids = 16:18
dmsp_dicts = map(ids) do id
    geo = Speasy.get_data("ssc/dmspf$id/geo", tr...)
    Dict(:id => id, :geo => geo)
end
```

### Convert coordinates to (MLT, MLat, Radius)

```{julia}
using IRBEM
using DimensionalData

function IRBEM.get_mlt(x)
    ts = times(x)
    mlt = IRBEM.get_mlt.(eachslice(parent(x), dims=1), ts)
    tdim = Ti(ts)
    metadata = Dict(:label => "MLT")
    return DimArray(mlt, tdim; metadata)
end

elx_mlt = get_mlt(elfin_x_geo)
elx_aacgm = geo2aacgm(elfin_x_geo)
elx_mlat = elx_aacgm.mlat

foreach(dmsp_dicts) do d
    mlt = get_mlt(d[:geo])
    aacgm = geo2aacgm(d[:geo])
    mlat = aacgm.mlat
    Δmlt = elx_mlt .- mlt
    Δmlat = elx_aacgm.mlat .- mlat
    d[:mlt] = rebuild(mlt; metadata=Dict(:label => "MLT DMSP$(d[:id])"))
    d[:aacgm] = rebuild(aacgm; metadata=Dict(:label => "AACGM DMSP$(d[:id])"))
    d[:mlat] = rebuild(mlat; metadata=Dict(:label => "MLAT DMSP$(d[:id])"))
    d[:Δmlt] = rebuild(Δmlt; metadata=Dict(:label => "ΔMLT DMSP$(d[:id])"))
    d[:Δmlat] = rebuild(Δmlat; metadata=Dict(:label => "ΔMLAT DMSP$(d[:id])"))
    d
end

Δmlts = getindex.(dmsp_dicts, :Δmlt)
Δmlats = getindex.(dmsp_dicts, :Δmlat)
```


### MLAT and MLT differences

Filter time ranges so that Δmlt < 1 and Δmlat < 8 for at least one DMSP

```{julia}
valid_ranges_with_ids = map(continuous_ranges) do ranges
    # Check which DMSP satellites satisfy the conditions
    valid_ids = Int[]
    for (i, (Δmlt, Δmlat)) in enumerate(zip(Δmlts, Δmlats))
        mlt_condition = any(abs.(tview(Δmlt, ranges...)) .< 1)
        mlat_condition = any(abs.(tview(Δmlat, ranges...)) .< 8)

        if mlt_condition && mlat_condition
            push!(valid_ids, ids[i])
        end
    end
    !isempty(valid_ids) ? (range=ranges, ids=valid_ids) : nothing
end

valid_ranges_with_ids = filter(!isnothing, valid_ranges_with_ids)
```

```{julia}
plot_elfin_dmsp(valid_ranges_with_ids[4]...)
```


Get the fluxes averaged over MLAT (0.5 MLAT bin) for each mission

```{julia}
using Statistics
using DataFrames, DataFramesMeta

# ELFIN
trange, ids = valid_ranges_with_ids[end-10]

elx_df = get_elfin_flux_by_mlat(elx_flux, elx_gei, trange)
dmsp_df = mapreduce(vcat, ids) do id
    df = get_dmsp_flux_by_mlat(trange, id)
    df.id .= id
    df
end

# join the dataframes based on mlat
join_df = leftjoin(elx_df, dmsp_df, on=:mlat, makeunique=true)
sort!(join_df, :mlat)
dropmissing!(join_df)
```

### Fit Fluxes

https://discourse.julialang.org/t/alternatives-to-lsqfit-for-nonlinear-curve-fitting/107685

https://juliastats.org/GLM.jl/dev/

https://discourse.julialang.org/t/comparing-non-linear-least-squares-solvers/104752/26

https://docs.sciml.ai/NonlinearSolve/stable/solvers/nonlinear_least_squares_solvers/

[FSSC: Fermi Data » Data Analysis » Analysis Threads » Source Model Definitions for gtlike](https://fermi.gsfc.nasa.gov/ssc/data/analysis/scitools/source_models.html)

<a href="https://gist.github.com/cgobat/12595d4e242576d4d84b1b682476317d">Overview of broken power law functions and fitting them to data</a>

<a href="https://docs.gammapy.org/0.19/modeling/gallery/index.html">Model gallery — gammapy v0.19</a>

- Power Law with Exponential Cutoff (PLEC)

$$
f(E) = A \cdot E^{-\gamma} \cdot \exp\left(-\frac{E}{E_c}\right)
$$

- Smooth Broken Power Law (SBPL):

$$
f(E) = A \cdot \left( \frac{E}{E_b} \right)^{-\gamma_1} \cdot \left[1 + \left(\frac{E}{E_b}\right)^m\right]^{(\gamma_1 - \gamma_2)/m}
$$

```{julia}
function fit_flux(row, model)
    elx_flux = row.flux ./ 1e6
    elx_energies = elx_flux.dims[1].val
    dmsp_flux = row.flux_1
    dmsp_energies = dmsp_flux.dims[1].val

    # Combine and filter out NaN values
    flux_all = vcat(parent(dmsp_flux), parent(elx_flux))
    energies = vcat(dmsp_energies, elx_energies)
    valid_idx = .!isnan.(flux_all) .& .!isnan.(energies)
    flux_all = flux_all[valid_idx]
    energies = energies[valid_idx]

    p0 = init_guess(model, energies, flux_all)
    fit = curve_fit(model, energies, log10.(flux_all), p0)
end
```

```{julia}
using LsqFit
using CurveFit
using SciMLBase

E = 10 .^ range(0.0, 3.0; length=100)

true_params = [1e5, 1.8, 80.0, 1e3, 4.5, 800.0]
log_flux = log_two_pop_model(true_params, E)
flux = 10 .^ log_flux .* (1 .+ 0.02 .* randn(length(E)))  # 10% noise
log_flux_data = log10.(flux)

p0 = [1e5, 2.0, 50.0, 1e2, 5.0, 500.0]  # [A1, γ1, Ec1, A2, γ2, Ec2]
# fit = curve_fit(log_two_pop_model, E, log_flux_data, p0)

prob = NonlinearCurveFitProblem(log_two_pop_model, p0, E, log_flux_data)
sol = solve(prob)
```

### Plot Fluxes with Fitted Functions

```{julia}
# Create plot
f = Figure()
axis = (xscale=log10,
    yscale=log10,
    title="Average Electron Flux",
    xlabel="Energy (eV)",
    ylabel="Flux (1/cm²·sr·s·eV)")
ax = Axis(f[1, 1]; axis...)

# Plot ELFIN flux with solid lines
# Get min and max mlat for color normalization
mlat_min = minimum(join_df.mlat)
mlat_max = maximum(join_df.mlat)
colorrange = (0, 1)

tdf = @subset(join_df, :nnan_count .> 8)

for row in eachrow(tdf)
    # Calculate color based on mlat value (normalized between 0 and 1)
    color = (row.mlat - mlat_min) / (mlat_max - mlat_min)
    label = string(round(row.mlat, digits=1))
    # Use the same color for both lines, different line styles
    lines!(row.flux ./ 1e6; label, color, colorrange)
    lines!(row.flux_1; label, color, colorrange)

    dmsp_energies = row.flux_1.dims[1].val
    Emin = minimum(dmsp_energies)

    # for (model, linestyle) in zip((log_plec_model, log_sbpl_model,), (:dot, :dash))
    #     fit = fit_flux(row, model)
    #     Es = logrange(5e1, 1e6, 100)
    #     flux_fit = 10 .^ model(Es, fit.param)
    #     lines!(ax, Es, flux_fit; label, color, colorrange, linestyle)
    # end

    for (model, linestyle) in zip((log_plec_sbpl_model_sciml, log_sbpl_model), (:dot, :dash, :dashdot))
        try
            sol = fit_flux_sciml(row, model)
            Es = logrange(Emin, 1e6, 100)
            p = sol.u
            @info p
            flux_fit = 10 .^ model(p, Es)
            lines!(ax, Es, flux_fit; label, color, colorrange, linestyle)
        catch
            @warn "Failed to fit $model"
        end

    end
end
axislegend(ax; merge=true)
# ylims!(ax, 1e-5, 1e6)
f
```



### Plot distance metrics


```{julia}
dist(mlt0::Number, mlt1::Number) = min(mod(mlt0 - mlt1, 24), mod(mlt1 - mlt0, 24))
dist((mlt0, mlat0), (mlt1, mlat1); dmlt=1, dmlat=8) =
    ifelse(dist(mlt0, mlt1) < dmlt, 0, 1) *
    ifelse(abs(mlat0 - mlat1) < dmlat, 0, 1)

dist_exp((mlt0, mlat0), (mlt1, mlat1); dmlt=1, dmlat=8) =
    (1 - exp(-dist(mlt0, mlt1) / dmlt) *
         exp(-abs(mlat0 - mlat1) / dmlat))

distances = map(1:3) do id_idx
    map(1:length(elx_mlt)) do i
        dist_exp((elx_mlt[i], elx_aacgm.mlat[i]), (dmsp_xs_mlt[id_idx][i], dmsp_xs_aacgm[id_idx].mlat[i]))
    end
end
```

```{julia}
f = Figure()
# First axis for normalized MLAT and MLT
ax1 = Axis(f[1, 1], xlabel="Time", ylabel="Normalized Value", title="ELFIN MLAT and MLT")
ts = times(elfin_x_geo)
scatterlines!(ax1, (90 .- elx_aacgm.mlat) ./ 180, label="MLAT (normalized) = (90 - MLAT) / 180")
scatterlines!(ax1, elx_mlt ./ 24, label="MLT (normalized) = MLT / 24")
axislegend(ax1, position=:rt)

# Second axis for MLT differences
ax2 = Axis(f[2, 1], xlabel="Time", ylabel="MLT Difference (normalized)", title="MLT Difference ELFIN vs DMSP")
foreach(1:3) do id_idx
    lines!(ax2, dist.(elx_mlt, dmsp_xs_mlt[id_idx]) ./ 24)
end

# Third axis for MLAT differences
ax3 = Axis(f[3, 1], xlabel="Time", ylabel="MLAT Difference (normalized)", title="MLAT Difference ELFIN vs DMSP")
foreach(1:3) do id_idx
    lines!(ax3, abs.(elx_aacgm.mlat .- dmsp_xs_aacgm[id_idx].mlat) ./ 180)
end

# Fourth axis for distances
ax4 = Axis(f[4, 1], xlabel="Time", ylabel="Distance", title="Combined Distance Metric")
foreach(1:3) do i
    lines!(ax4, ts, distances[i], label="DMSP F$(i+15)")
end
axislegend(ax4, position=:rt)

# Link x-axes so they zoom/pan together
linkxaxes!(ax1, ax2, ax3, ax4)

f
```

## Check

Compare the MLAT of DMSP from our calculation and the one in the file

```{julia}
using SpaceDataModel: set!

dmsp_calc_aacgm = dmsp_get_aacgm(timerange, id)
dmsp_calc_mlat = getindex.(dmsp_calc_aacgm, 1)
set!(dmsp_calc_mlat.metadata, :label => "AACGM", :ylabel => "MLAT")
dmsp_file_mlat = dmsp_load(timerange, id, "mlat")
set!(dmsp_file_mlat.metadata, :label => "File", :ylabel => "MLAT")

tplot(([dmsp_calc_mlat, dmsp_file_mlat],))
```

```{julia}
norm_times(ts) = (ts .- ts[1]) ./ (ts[end] - ts[1])

f = Figure()
ax1 = Axis3(f[1, 1], aspect=(2, 1, 1), xlabel="Time", ylabel="MLat", zlabel="MLT")

lines!(ax1, norm_times(times(elfin_x_geo)), parent(elx_aacgm.mlat), parent(elx_mlt), linewidth=4)

for i in 1:length(dmsp_xs_geo)
    lines!(ax1, norm_times(times(dmsp_xs_geo[i])), parent(dmsp_xs_aacgm[i].mlat), parent(dmsp_xs_mlt[i]))
end

f
```

```{julia}
using SPEDAS: tplot

f = Figure()
dmsp_tvars = (dms_ds.el_d_flux, dms_ds.ion_d_flux, (dmspf16_aacgm.mlat, dms_ds.mlat), (dmspf16_mlt, dms_ds.mlt))
elx_tvars = (elx_aacgm.mlat, elx_mlt)
tplot(f[1, 1], dmsp_tvars)
tplot(f[1, 2], elx_tvars)
f
```

## Validation of DMSP Fluxes

@redmonNewDMSPDatabase2017

> The total number (energy) flux is calculated in the following manner (adapted from Hardy et al. [2008]) by “integrating” differential number (energy) fluxes (equation (2)) over energy:

$$
J_{N, \text { Total }}(\Omega)=j_N\left(E_1, \Omega\right)\left(E_2-E_1\right)+\left[\sum_{i=2}^{18} j_N\left(E_i, \Omega\right) \frac{\left(E_{i+1}-E_{i-1}\right)}{2}\right]+j_N\left(E_{19}, \Omega\right)\left(E_{19}-E_{18}\right) .
$$

```{julia}
dmsp_flux = dmsp_load(["2010-01-10T00:05", "2010-01-10T00:35"], 16, "el_d_ener")
dmsp_J = integrate_diff_flux(dmsp_flux)

dmsp_J = SPEDAS.set_meta(dmsp_J, :scale => log10)
tplot([dmsp_flux, dmsp_J])
ylims!(current_axis(), 1e9, 1e13)
current_figure()
```