---
title: "ELFIN Data Analysis"
engine: julia
---

# ELFIN Data Analysis

This document analyzes ELFIN satellite data to find continuous time ranges and prepare for conjunction analysis with DMSP.

## Loading ELFIN Flux Data

```{julia}
using PySPEDAS.Projects
using PySPEDAS
using PySPEDAS.PythonCall
using Speasy
using Dates
using DimensionalData

probe = "b"
tr = ["2021-01-01", "2021-02-01"]

# Load ELFIN EPD data
epd_ds = elfin.epd(tr; probe, level="l2")
elx_flux = DimArray(epd_ds.elb_pef_hs_nflux_para)
```

## Finding Continuous Time Ranges

```{julia}
using SPEDAS
using SPEDAS: find_continuous_timeranges

continuous_ranges = find_continuous_timeranges(elx_flux, Second(60))

# Print the continuous time ranges
println("Found $(length(continuous_ranges)) continuous time ranges:")
for (i, (start_time, end_time)) in enumerate(continuous_ranges)
    duration = end_time - start_time
    println("Range $i: $start_time to $end_time ($(round(duration, Minute)))")
end
```

Download data from Madrigal for each continuous time range

```{julia}
using MadrigalWeb
MadrigalWeb.Default_server[] = MadrigalWeb.MadrigalData("https://cedar.openmadrigal.org")
MadrigalWeb.set_default_server()
MadrigalWeb.set_default_user("Zijin+Zhang", "zijin@ucla.edu")

# timeranges_day = sort(collect(Set((floor(t0, Day), ceil(t1, Day)) for (t0, t1) in continuous_ranges)))

function dmsp_download(timerange, inst=8100, kindat=10216)
    MadrigalWeb.download_files(inst, kindat, timerange...)
end
dmsp_download.(continuous_ranges)
```


## Loading ELFIN Position Data


```{julia}
const ssc = speasy.inventories.flat_inventories.ssc
dmspf16_ssc = speasy.inventories.data_tree.ssc.Trajectories.dmspf16
elfina_ssc = speasy.inventories.data_tree.ssc.Trajectories.elfina
speasy.inventories.flat_inventories.ssc.parameters.keys()

# mms1_traj = speasy.ssc.get_data(speasy.inventories.data_tree.ssc.Trajectories.mms1, "2018-01-01", "2018-02-01", "gsm")
# mms1_traj.columns

probe = "b"
test_timerange = ("2020-01-08", "2020-01-09")

dmspf16_geo = Speasy.ssc_get_data("dmspf16", test_timerange..., "geo")
elfinx_geo = Speasy.ssc_get_data("elfin$probe", test_timerange..., "geo")

epd_ds = elfin.epd(test_timerange; probe, level="l2")
elx_flux = DimArray(getproperty(epd_ds, Symbol(:el, probe, :_pef_hs_nflux_para)))
elx_energies = pyconvert(Vector{Float64}, PySPEDAS.get_data("el$(probe)_pef_energies_mean"; xarray=false))
elx_flux = rebuild(elx_flux, dims=(Ti(parent(elx_flux.dims[1])), Y(elx_energies)))


set_if_valid!(elx_flux.metadata, :yscale => identity, :scale => log10, :colorrange => (1e3, 1e8))
replace!(elx_flux, 0 => NaN)
```

Interpolate ELFIN position data to 1 second resolution


## Convert coordinates to (MLT, MLat, Radius)

```{julia}
using Aacgm
using DimensionalData.Dimensions: TimeDim
using HybridArrays
using IRBEM

function Aacgm.geo2aacgm(x)
    ts = times(x)
    aacgm = Aacgm.geo2aacgm.(eachslice(x, dims=2)..., ts)
    tdim = Ti(ts)
    mlat = DimArray(getindex.(aacgm, 1), tdim)
    mlon = DimArray(getindex.(aacgm, 2), tdim)
    return DimStack((; mlat, mlon))
end

function IRBEM.get_mlt(x)
    ts = times(x)
    mlt = IRBEM.get_mlt.(eachslice(x, dims=1), ts)
    tdim = Ti(ts)
    return DimArray(mlt, tdim)
end

dmspf16_mlt = get_mlt(dmspf16_geo)
dmspf16_aacgm = geo2aacgm(dmspf16_geo)
elx_mlt = get_mlt(elfinx_geo)
elx_aacgm = geo2aacgm(elfinx_geo)
```

Compare the MLAT of DMSP from our calculation and the one in the file

```{julia}
using SPEDAS: tplot

f = Figure()
dmsp_tvars = (dms_ds.el_d_flux, dms_ds.ion_d_flux, (dmspf16_aacgm.mlat, dms_ds.mlat), (dmspf16_mlt, dms_ds.mlt))
elx_tvars = (elx_aacgm.mlat, elx_mlt)
tplot(f[1, 1], dmsp_tvars)
tplot(f[1, 2], elx_tvars)
f
```


Overplot the fluxes

```{julia}
using SPEDAS: tplot

tvars = (dms_ds.el_d_flux, elx_flux, (dmspf16_aacgm.mlat, elx_aacgm.mlat), (dmspf16_mlt, elx_mlt))
tplot(tvars)
```
